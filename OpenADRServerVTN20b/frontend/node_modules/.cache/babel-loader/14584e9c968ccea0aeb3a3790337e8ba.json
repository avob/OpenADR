{"ast":null,"code":"(function () {\n  var UtfString;\n\n  if (typeof exports !== 'undefined' && exports !== null) {\n    UtfString = exports;\n  } else if (typeof window !== 'undefined' && window !== null) {\n    if (typeof window.UtfString === 'undefined' || window.UtfString === null) {\n      window.UtfString = {};\n    }\n\n    UtfString = window.UtfString;\n  }\n\n  function factory(obj, graphemeClusterRegexes) {\n    obj.findCharIndex = function (string, byteIndex) {\n      if (byteIndex >= string.length) {\n        return -1;\n      } // optimization: don't iterate unless necessary\n\n\n      if (!containsGraphemeClusterGroup(string)) {\n        return byteIndex;\n      }\n\n      var scanner = createScanner();\n      var charCount = 0;\n\n      while (scanner.exec(string) !== null) {\n        if (scanner.lastIndex > byteIndex) {\n          break;\n        }\n\n        charCount++;\n      }\n\n      return charCount;\n    };\n\n    obj.findByteIndex = function (string, charIndex) {\n      if (charIndex >= this.length(string)) {\n        return -1;\n      }\n\n      return scan(string, createScanner(), charIndex);\n    };\n\n    obj.charAt = function (string, index) {\n      var byteIndex = this.findByteIndex(string, index);\n\n      if (byteIndex < 0 || byteIndex >= string.length) {\n        return '';\n      }\n\n      var characters = string.slice(byteIndex, byteIndex + 8);\n      var match = graphemeClusterRegex.exec(characters);\n\n      if (match === null) {\n        return characters[0];\n      } else {\n        return match[0];\n      }\n    };\n\n    obj.charCodeAt = function (string, index) {\n      var byteIndex = findSurrogateByteIndex(string, index);\n\n      if (byteIndex < 0) {\n        return NaN;\n      }\n\n      var code = string.charCodeAt(byteIndex);\n\n      if (0xD800 <= code && code <= 0xDBFF) {\n        var hi = code;\n        var low = string.charCodeAt(byteIndex + 1);\n        return (hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000;\n      }\n\n      return code;\n    };\n\n    obj.fromCharCode = function (charCode) {\n      if (charCode > 0xFFFF) {\n        charCode -= 0x10000;\n        return String.fromCharCode(0xD800 + (charCode >> 10), 0xDC00 + (charCode & 0x3FF));\n      } else {\n        return String.fromCharCode(charCode);\n      }\n    };\n\n    obj.indexOf = function (string, searchValue, start) {\n      if (typeof start === 'undefined' || start === null) {\n        start = 0;\n      }\n\n      var startByteIndex = this.findByteIndex(string, start);\n      var index = string.indexOf(searchValue, startByteIndex);\n\n      if (index < 0) {\n        return -1;\n      } else {\n        return this.findCharIndex(string, index);\n      }\n    };\n\n    obj.lastIndexOf = function (string, searchValue, start) {\n      var index;\n\n      if (typeof start === 'undefined' || start === null) {\n        index = string.lastIndexOf(searchValue);\n      } else {\n        var startByteIndex = this.findByteIndex(string, start);\n        index = string.lastIndexOf(searchValue, startByteIndex);\n      }\n\n      if (index < 0) {\n        return -1;\n      } else {\n        return this.findCharIndex(string, index);\n      }\n    };\n\n    obj.slice = function (string, start, finish) {\n      var startByteIndex = this.findByteIndex(string, start);\n      var finishByteIndex;\n\n      if (startByteIndex < 0) {\n        startByteIndex = string.length;\n      }\n\n      if (typeof finish === 'undefined' || finish === null) {\n        finishByteIndex = string.length;\n      } else {\n        finishByteIndex = this.findByteIndex(string, finish);\n\n        if (finishByteIndex < 0) {\n          finishByteIndex = string.length;\n        }\n      }\n\n      return string.slice(startByteIndex, finishByteIndex);\n    };\n\n    obj.substr = function (string, start, length) {\n      if (start < 0) {\n        start = this.length(string) + start;\n      }\n\n      if (typeof length === 'undefined' || length === null) {\n        return this.slice(string, start);\n      } else {\n        return this.slice(string, start, start + length);\n      }\n    }; // they do the same thing\n\n\n    obj.substring = obj.slice;\n\n    obj.length = function (string) {\n      // findCharIndex will return -1 if string is empty, so add 1\n      return this.findCharIndex(string, string.length - 1) + 1;\n    };\n\n    obj.stringToCodePoints = function (string) {\n      var result = [];\n\n      for (var i = 0; i < string.length; i++) {\n        codePoint = this.charCodeAt(string, i);\n\n        if (!codePoint) {\n          break;\n        }\n\n        result.push(codePoint);\n      }\n\n      return result;\n    };\n\n    obj.codePointsToString = function (arr) {\n      var chars = [];\n\n      for (var i = 0; i < arr.length; i++) {\n        chars.push(this.fromCharCode(arr[i]));\n      }\n\n      return chars.join('');\n    };\n\n    obj.stringToBytes = function (string) {\n      var result = [];\n\n      for (var i = 0; i < string.length; i++) {\n        var chr = string.charCodeAt(i);\n        var byteArray = [];\n\n        while (chr > 0) {\n          byteArray.push(chr & 0xFF);\n          chr >>= 8;\n        } // all utf-16 characters are two bytes\n\n\n        if (byteArray.length == 1) {\n          byteArray.push(0);\n        } // assume big-endian\n\n\n        result = result.concat(byteArray.reverse());\n      }\n\n      return result;\n    };\n\n    obj.bytesToString = function (arr) {\n      var result = [];\n\n      for (var i = 0; i < arr.length; i += 2) {\n        var hi = arr[i];\n        var low = arr[i + 1];\n        var combined = hi << 8 | low;\n        result.push(String.fromCharCode(combined));\n      }\n\n      return result.join('');\n    };\n\n    obj.stringToCharArray = function (string) {\n      var result = [];\n      var scanner = createScanner();\n\n      do {\n        var match = scanner.exec(string);\n\n        if (match === null) {\n          break;\n        }\n\n        result.push(match[0]);\n      } while (match !== null);\n\n      return result;\n    };\n\n    function findSurrogateByteIndex(string, charIndex) {\n      return scan(string, new RegExp(surrogatePairs.source, 'g'), charIndex);\n    }\n\n    function scan(string, scanner, charIndex) {\n      // optimization: don't iterate unless it's necessary\n      if (!containsGraphemeClusterGroup(string)) {\n        return charIndex;\n      }\n\n      var byteIndex = 0;\n      var charCount = 0;\n\n      do {\n        var match = scanner.exec(string);\n\n        if (match === null) {\n          break;\n        }\n\n        if (charCount < charIndex) {\n          byteIndex += match[0].length;\n          charCount++;\n        } else {\n          break;\n        }\n      } while (match !== null);\n\n      if (byteIndex >= string.length) {\n        return -1;\n      }\n\n      return byteIndex;\n    }\n\n    function containsGraphemeClusterGroup(string) {\n      return graphemeClusterRegex.test(string);\n    }\n\n    function createScanner(extraSources, modifiers) {\n      if (extraSources == undefined) {\n        extraSources = ['[^]'];\n      }\n\n      if (modifiers == undefined) {\n        modifiers = 'g';\n      }\n\n      var sources = [];\n      graphemeClusterRegexes.forEach(function (re) {\n        sources.push(re.source);\n      });\n      sources.push(surrogatePairs.source);\n      sources = sources.concat(extraSources);\n      return new RegExp(sources.join('|'), modifiers);\n    }\n\n    var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\n    var graphemeClusterRegex = createScanner([], '');\n  }\n\n  var regionalIndicatorPairs = /\\uD83C[\\uDDE6-\\uDDFF]\\uD83C[\\uDDE6-\\uDDFF]/;\n  UtfString.visual = {};\n  factory(UtfString, []);\n  factory(UtfString.visual, [regionalIndicatorPairs]);\n})();","map":null,"metadata":{},"sourceType":"script"}