{"ast":null,"code":"(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define('parseXsdDuration', ['exports'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.parseXsdDuration = mod.exports;\n  }\n})(this, function (exports) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _emptyPeriod, _emptyTime;\n\n  var UNITS = {\n    YEAR: 31536000,\n    MONTH: 2628000,\n    DAY: 86400,\n    HOUR: 3600,\n    MINUTE: 60,\n    SECOND: 1\n  };\n  var YEAR_UNIT = 'years';\n  var MONTH_UNIT = 'months';\n  var DAY_UNIT = 'days';\n  var HOUR_UNIT = 'hours';\n  var MINUTE_UNIT = 'minutes';\n  var SECOND_UNIT = 'seconds';\n  var IS_NEGATIVE_UNIT = 'isNegative';\n  var emptyPeriod = (_emptyPeriod = {}, _emptyPeriod[YEAR_UNIT] = 0, _emptyPeriod[MONTH_UNIT] = 0, _emptyPeriod[DAY_UNIT] = 0, _emptyPeriod);\n  var emptyTime = (_emptyTime = {}, _emptyTime[HOUR_UNIT] = 0, _emptyTime[MINUTE_UNIT] = 0, _emptyTime[SECOND_UNIT] = 0, _emptyTime); // Regex taken from https://www.w3.org/TR/xmlschema11-2/#duration-lexical-space\n\n  var isValidXsdDuration = function isValidXsdDuration(str) {\n    return /^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$/.test(str);\n  };\n\n  var isNonEmptyString = function isNonEmptyString(input) {\n    return typeof input === 'string' && input.length > 0;\n  };\n\n  var isNegative = function isNegative(str) {\n    return str[0] === '-';\n  };\n\n  var stripFirstChar = function stripFirstChar(str) {\n    return str.slice(1);\n  };\n\n  var unitToSeconds = function unitToSeconds(unit, amount) {\n    return UNITS[unit.toUpperCase()] * amount;\n  };\n\n  var parseUnit = function parseUnit(unit, amount) {\n    var amt = getNumber(amount);\n    return unitToSeconds(unit, amt);\n  };\n\n  var getNumber = function getNumber(amount) {\n    var amt = parseFloat(amount);\n    if (isNaN(amt)) return 0;\n    return amt;\n  };\n\n  var parsePeriod = function parsePeriod(period) {\n    var _ref = /^(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?$/g.exec(period) || [],\n        year = _ref[1],\n        month = _ref[2],\n        day = _ref[3];\n\n    return parseUnit('year', year) + parseUnit('month', month) + parseUnit('day', day);\n  };\n\n  var parsePeriodToObject = function parsePeriodToObject(period) {\n    var _ref3;\n\n    var _ref2 = /^(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?$/g.exec(period) || [],\n        years = _ref2[1],\n        months = _ref2[2],\n        days = _ref2[3];\n\n    return _ref3 = {}, _ref3[YEAR_UNIT] = getNumber(years), _ref3[MONTH_UNIT] = getNumber(months), _ref3[DAY_UNIT] = getNumber(days), _ref3;\n  };\n\n  var parseTime = function parseTime(time) {\n    var _ref4 = /^(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?$/g.exec(time) || [],\n        hour = _ref4[1],\n        minute = _ref4[2],\n        second = _ref4[3];\n\n    return parseUnit('hour', hour) + parseUnit('minute', minute) + parseUnit('second', second);\n  };\n\n  var parseTimeToObject = function parseTimeToObject(time) {\n    var _ref6;\n\n    var _ref5 = /^(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?$/g.exec(time) || [],\n        hours = _ref5[1],\n        minutes = _ref5[2],\n        seconds = _ref5[3];\n\n    return _ref6 = {}, _ref6[HOUR_UNIT] = getNumber(hours), _ref6[MINUTE_UNIT] = getNumber(minutes), _ref6[SECOND_UNIT] = getNumber(seconds), _ref6;\n  };\n\n  var parse = function parse(str) {\n    var neg = isNegative(str);\n    var duration = neg ? stripFirstChar(str) : str;\n    var splitDuration = duration.split('T');\n    var period = stripFirstChar(splitDuration[0]);\n    var time = splitDuration[1];\n    var output = 0;\n    if (isNonEmptyString(period)) output += parsePeriod(period);\n    if (isNonEmptyString(time)) output += parseTime(time);\n    return neg ? -output : output;\n  };\n\n  var convertToObject = exports.convertToObject = function convertToObject(str) {\n    var _output;\n\n    var neg = isNegative(str);\n    var duration = neg ? stripFirstChar(str) : str;\n    var splitDuration = duration.split('T');\n    var period = stripFirstChar(splitDuration[0]);\n    var time = splitDuration[1];\n    var output = (_output = {}, _output[IS_NEGATIVE_UNIT] = neg, _output);\n    output = isNonEmptyString(period) ? Object.assign(output, parsePeriodToObject(period)) : Object.assign(output, emptyPeriod);\n    output = isNonEmptyString(time) ? Object.assign(output, parseTimeToObject(time)) : Object.assign(output, emptyTime);\n    return output;\n  };\n\n  var out = function out(input) {\n    var toObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // Throw error for non-string input\n\n    if (typeof input !== 'string') {\n      throw new TypeError('expected input to be a string');\n    } // Return null for invalid input\n\n\n    if (!isValidXsdDuration(input)) return null; // Parse valid input\n\n    return toObject ? convertToObject(input) : parse(input);\n  };\n\n  exports.default = function (input, toObject) {\n    return out(input, toObject);\n  };\n});","map":null,"metadata":{},"sourceType":"script"}