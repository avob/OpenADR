{"version":3,"sources":["../src/index.js"],"names":["UNITS","YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","YEAR_UNIT","MONTH_UNIT","DAY_UNIT","HOUR_UNIT","MINUTE_UNIT","SECOND_UNIT","IS_NEGATIVE_UNIT","emptyPeriod","emptyTime","isValidXsdDuration","test","str","isNonEmptyString","input","length","isNegative","stripFirstChar","slice","unitToSeconds","unit","amount","toUpperCase","parseUnit","amt","getNumber","parseFloat","isNaN","parsePeriod","exec","period","year","month","day","parsePeriodToObject","years","months","days","parseTime","time","hour","minute","second","parseTimeToObject","hours","minutes","seconds","parse","neg","duration","splitDuration","split","output","convertToObject","Object","assign","out","toObject","TypeError"],"mappings":"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","file":"index.js","sourcesContent":["const UNITS = {\n  YEAR: 31536000,\n  MONTH: 2628000,\n  DAY: 86400,\n  HOUR: 3600,\n  MINUTE: 60,\n  SECOND: 1\n}\n\nconst YEAR_UNIT = 'years'\nconst MONTH_UNIT = 'months'\nconst DAY_UNIT = 'days'\nconst HOUR_UNIT = 'hours'\nconst MINUTE_UNIT = 'minutes'\nconst SECOND_UNIT = 'seconds'\nconst IS_NEGATIVE_UNIT = 'isNegative'\n\nconst emptyPeriod = {\n  [YEAR_UNIT]: 0,\n  [MONTH_UNIT]: 0,\n  [DAY_UNIT]: 0\n}\n\nconst emptyTime = {\n  [HOUR_UNIT]: 0,\n  [MINUTE_UNIT]: 0,\n  [SECOND_UNIT]: 0\n}\n\n// Regex taken from https://www.w3.org/TR/xmlschema11-2/#duration-lexical-space\nconst isValidXsdDuration = str =>\n  /^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$/.test(\n    str\n  )\nconst isNonEmptyString = input => typeof input === 'string' && input.length > 0\nconst isNegative = str => str[0] === '-'\nconst stripFirstChar = str => str.slice(1)\nconst unitToSeconds = (unit, amount) => UNITS[unit.toUpperCase()] * amount\n\nconst parseUnit = (unit, amount) => {\n  const amt = getNumber(amount)\n  return unitToSeconds(unit, amt)\n}\n\nconst getNumber = amount => {\n  const amt = parseFloat(amount)\n  if (isNaN(amt)) return 0\n  return amt\n}\n\nconst parsePeriod = period => {\n  const [, year, month, day] =\n    /^(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?$/g.exec(period) || []\n\n  return (\n    parseUnit('year', year) + parseUnit('month', month) + parseUnit('day', day)\n  )\n}\n\nconst parsePeriodToObject = period => {\n  const [, years, months, days] =\n    /^(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?$/g.exec(period) || []\n\n  return {\n    [YEAR_UNIT]: getNumber(years),\n    [MONTH_UNIT]: getNumber(months),\n    [DAY_UNIT]: getNumber(days)\n  }\n}\n\nconst parseTime = time => {\n  const [, hour, minute, second] =\n    /^(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?$/g.exec(time) || []\n\n  return (\n    parseUnit('hour', hour) +\n    parseUnit('minute', minute) +\n    parseUnit('second', second)\n  )\n}\n\nconst parseTimeToObject = time => {\n  const [, hours, minutes, seconds] =\n    /^(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?$/g.exec(time) || []\n\n  return {\n    [HOUR_UNIT]: getNumber(hours),\n    [MINUTE_UNIT]: getNumber(minutes),\n    [SECOND_UNIT]: getNumber(seconds)\n  }\n}\n\nconst parse = str => {\n  const neg = isNegative(str)\n  const duration = neg ? stripFirstChar(str) : str\n  const splitDuration = duration.split('T')\n  const period = stripFirstChar(splitDuration[0])\n  const time = splitDuration[1]\n\n  let output = 0\n  if (isNonEmptyString(period)) output += parsePeriod(period)\n  if (isNonEmptyString(time)) output += parseTime(time)\n  return neg ? -output : output\n}\n\nexport const convertToObject = str => {\n  const neg = isNegative(str)\n  const duration = neg ? stripFirstChar(str) : str\n  const splitDuration = duration.split('T')\n  const period = stripFirstChar(splitDuration[0])\n  const time = splitDuration[1]\n\n  let output = { [IS_NEGATIVE_UNIT]: neg }\n  output = isNonEmptyString(period)\n    ? Object.assign(output, parsePeriodToObject(period))\n    : Object.assign(output, emptyPeriod)\n  output = isNonEmptyString(time)\n    ? Object.assign(output, parseTimeToObject(time))\n    : Object.assign(output, emptyTime)\n  return output\n}\n\nconst out = (input, toObject = false) => {\n  // Throw error for non-string input\n  if (typeof input !== 'string') {\n    throw new TypeError('expected input to be a string')\n  }\n  // Return null for invalid input\n  if (!isValidXsdDuration(input)) return null\n  // Parse valid input\n  return toObject ? convertToObject(input) : parse(input)\n}\n\nexport default (input, toObject) => out(input, toObject)\n"]}